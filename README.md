# 프로젝트 설명
이 프로젝트는 JWT 기반 인증 시스템을 구현한 Spring Boot 애플리케이션입니다. 
<br>
시스템의 핵심은 사용자 인증, 역할 기반 권한 부여, JWT 토큰 발급 및 재발급 기능을 포함한 보안 처리입니다.
<br>
사용자 정보를 메모리 기반 Map을 이용하여 관리하고 각종 예외 처리 및 Swagger UI를 통한 API 문서화가 이루어졌습니다.
<br>
- 깃허브 링크: https://github.com/luz315/s_test
- 배포 주소: http://0.0.0.0:8080/ 
- 스웨거 주소: http://0.0.0.0:8080/ or http://0.0.0.0:8080/doc (둘 다 가능)

<br>

## 실행 방법
- http://0.0.0.0:8080/ 해당 주소로 입장하게 되면 API를 테스트 할 수 있습니다.
- 토큰 재발급 API 사용법
  - 로그인 API 먼저 실행 후 개발자 도구에서 얻은 쿠키를 파라미터에 입력하면 재발급 처리가 가능합니다.
- 어드민 권한 부여 API 사용법
  - [username: admin, password: admin1234]로 로그인 후 response에 나온 액세스 토큰값을 스웨거 상단 Authorize에 기입 후 실행합니다. (이때 일반 유저의 아이디를 파라미터에 기입해야 하므로 일반유저 계정으로 회원가입 후 해당 계정을 적어주세요)
- 계정 삭제 API 사용법
  - 본인의 계정만 삭제가 가능하므로 로그인 후 Authorize에 액세스토큰을 기입하고 실행해주세요.

<br>

## API 명세 (Swagger UI를 통해 확인할 수 있습니다)
| **기능**           | **요청 방식** | **URL 경로**                  | **요청 본문**                                          | **응답 본문**                                                       |
|--------------------|---------------|-------------------------------|------------------------------------------------------|---------------------------------------------------------------------|
| **회원가입**        | `POST`        | `/signup`                      | `{ "username": "user1", "password": "password123", "nickname": "user1" }` | `200 OK: { "message": "회원 가입이 완료되었습니다.", "data": { "username": "user1", "nickname": "user1" }}` |
| **회원탈퇴**        | `DELETE`      | `/delete`                      | (Authorization 헤더의 JWT 토큰에서 사용자 정보 확인) | `200 OK: { "message": "회원 탈퇴가 완료되었습니다." }`               |
| **로그인**          | `POST`        | `/login`                       | `{ "username": "user1", "password": "password123" }` | `200 OK: { "accessToken": "Bearer <JWT>" }`                         |
| **로그아웃**        | `POST`        | `/logout`                      | (Authorization 헤더의 JWT 토큰에서 사용자 정보 확인) | `200 OK: { "message": "로그아웃 성공" }`                            |
| **어드민 권한 부여** | `PATCH`       | `/admin/{targetUsername}/roles` | (Authorization 헤더에 ADMIN 권한을 가진 사용자 토큰 필요) | `200 OK: { "message": "관리자 권한이 부여되었습니다.", "data": { "username": "user1", "role": "ADMIN" }}` |
| **토큰 재발급**     | `POST`        | `/reissue`                     | (Cookie에 저장된 refreshToken)                       | `200 OK: { "message": "토큰이 재발급되었습니다." }`                   |

<br>

## 구현 포인트

### 1. 메모리 기반 데이터 관리 (`UserRepository`의 `HashMap` 사용)

#### 문제와 해결:
이 시스템은 **DB 없이 사용자 정보를 관리**해야 하는 환경에서 효율적인 대체 방법을 모색했습니다.
<br>
**HashMap**을 사용하여 사용자 데이터를 메모리 내에서 관리하도록 설계했습니다.


#### 왜 HashMap을 사용했는가?
- `HashMap`은 **상수 시간 복잡도**인 **O(1)**을 보장하는 자료구조로 사용자 정보의 **조회, 추가, 삭제**가 매우 빠릅니다.
- 대규모 데이터를 다루지 않는 한 **DB보다 더 효율적**일 수 있습니다.

---

### 2. JWT 기반 인증 및 권한 관리

#### 왜 JWT를 왜 로그인 필터를 사용했는가?
JWT 기반 인증을 사용하여 세션 관리 없이 인증을 처리하려면 로그인 과정에서 JWT 토큰을 발급하는 과정이 필요해 LoginFilter를 사용했습니다.
<br>
LoginFilter는 UsernamePasswordAuthenticationFilter를 확장하여 로그인 요청 시에 아이디와 비밀번호를 받아 인증하고 JWT 토큰을 발급하는 역할을 합니다.

#### 왜 HttpOnly 쿠키에 Refresh Token을 저장했는가?
쿠키에 HttpOnly 속성을 설정해 JavaScript에서 해당 토큰에 접근하지 못하게 하고 XSS 공격으로 부터 Refresh Token을 보호합니다.

#### 보안 처리:
- **JWT 토큰 만료**: 각 토큰에 **만료 시간을 설정**하여 불필요한 인증 갱신 요청을 방지하고, 만료된 토큰에 대해서는 즉시 **액세스 제한**을 설정합니다.
- **Refresh Token**: **Access Token**이 만료된 경우 **Refresh Token**을 이용해 재발급받을 수 있게 하여, 사용자 경험을 **중단 없이 유지**합니다.
- **유효성 검사**: `JwtValidator` 클래스를 통해 토큰의 유효성 및 만료 여부를 철저히 검사하여 **보안을 강화**합니다.

---

### 3. 커스텀 로그아웃 필터 (CustomLogoutFilter)

- JWT 인증 방식에서는 세션을 유지하지 않기 때문에 로그아웃 시 클라이언트 측에서 토큰을 삭제해야 합니다. 
- 서버에서는 토큰을 관리하지 않기 때문에 Refresh Token을 클라이언트 쿠키에서 삭제하고 SecurityContextHolder를 초기화하여 인증 세션을 종료합니다.

---

### 4. 커스텀 예외 처리 시스템 (CustomException과 GlobalExceptionHandler)

#### 문제와 해결:
각종 예외가 발생할 수 있는 상황에서 예외를 **일관성 있게 처리**하고 **사용자에게 친절한 오류 메시지**를 제공했습니다. 

#### 구현 방식:
- `CustomException`을 사용하여 **오류 메시지와 상태 코드**를 설정하고 **에러 응답을 표준화**했습니다.
- `GlobalExceptionHandler`를 통해 발생할 수 있는 **모든 예외를 처리**해서 시스템이 중단되지 않도록 안전하게 예외를 처리합니다.

---

### 5. 공통 응답 처리 시스템 (ApiResult 클래스를 통한 일관된 응답 처리)

- 각 API의 응답은 HTTP 상태 코드 외에도 응답 코드, 메시지, 데이터를 포함하여 클라이언트가 처리할 수 있는 형식으로 구성했습니다.
- 서버에서 발생할 수 있는 다양한 오류에 대해 표준화된 방식으로 오류 메시지를 제공하고 HTTP 상태 코드와 함께 전달했습니다.

---

### **6. 리졸버를 이용한 `@CurrentUser` 자동 주입**

- 이 방식은 **반복적인 인증 로직**을 줄이고 코드의 **가독성**과 **유지보수성**을 높였습니다.
- **커스텀 리졸버**를 사용함으로써 **Spring Security**와의 통합을 자연스럽게 처리할 수 있습니다.
